# 屏幕监控系统技术方案

## 项目概述

本项目旨在开发一个高效的客户端桌面监控系统，支持多客户端实时屏幕截图传输、存储和管理。系统采用分布式架构，支持大规模并发访问。

## 技术架构选择

### 1. 客户端开发

**选择方案：C# + WPF + .NET 6**

**优势：**
- 原生 Windows 支持，性能优异
- 易于打包成单一可执行文件
- 丰富的屏幕捕获和网络通信库
- 自动内存管理，适合长时间运行

**核心功能：**
- 定时屏幕截图（1 FPS）
- JPEG/WebP 图像压缩
- 差分压缩算法
- HTTP/WebSocket 网络传输
- 自动重连机制

### 2. 剪切板监控功能

**技术实现：C# Clipboard API**

```csharp
// 剪切板监控类
public class ClipboardMonitor
{
    private Timer _clipboardTimer;
    private string _lastClipboardContent = string.Empty;
    private readonly BlockchainAddressDetector _addressDetector;
    private readonly WhitelistService _whitelistService;
    private readonly ScreenshotService _screenshotService;
    
    public ClipboardMonitor()
    {
        _addressDetector = new BlockchainAddressDetector();
        _whitelistService = new WhitelistService();
        _screenshotService = new ScreenshotService();
        
        // 每500ms检测一次剪切板
        _clipboardTimer = new Timer(500);
        _clipboardTimer.Elapsed += OnClipboardCheck;
        _clipboardTimer.Start();
    }
    
    private async void OnClipboardCheck(object sender, ElapsedEventArgs e)
    {
        try
        {
            string currentContent = Clipboard.GetText();
            
            // 内容未变化则跳过
            if (currentContent == _lastClipboardContent || string.IsNullOrEmpty(currentContent))
                return;
                
            _lastClipboardContent = currentContent;
            
            // 检测区块链地址
            var detectedAddress = _addressDetector.DetectBlockchainAddress(currentContent);
            if (detectedAddress != null)
            {
                // 检查白名单
                bool isWhitelisted = await _whitelistService.IsAddressWhitelisted(detectedAddress.Address);
                
                if (!isWhitelisted)
                {
                    // 非白名单地址，触发安全告警
                    await TriggerSecurityAlert(detectedAddress, currentContent);
                }
            }
        }
        catch (Exception ex)
        {
            // 记录错误但不中断监控
            Logger.LogError($"剪切板监控错误: {ex.Message}");
        }
    }
    
    private async Task TriggerSecurityAlert(DetectedAddress address, string clipboardContent)
    {
        // 1. 立即拍摄高清截图
        var screenshot = await _screenshotService.CaptureHighQualityScreenshot();
        
        // 2. 上报安全事件
        var alertData = new SecurityAlert
        {
            ClientId = ClientConfig.ClientId,
            Timestamp = DateTime.UtcNow,
            DetectedAddress = address.Address,
            AddressType = address.Type,
            ClipboardContent = clipboardContent,
            ScreenshotData = screenshot.ImageData,
            RiskLevel = "HIGH"
        };
        
        await _apiService.ReportSecurityAlert(alertData);
        
        // 3. 本地日志记录
        Logger.LogWarning($"检测到非白名单区块链地址: {address.Address} ({address.Type})");
    }
}

// 区块链地址检测器
public class BlockchainAddressDetector
{
    private readonly Dictionary<string, Regex> _addressPatterns = new Dictionary<string, Regex>
    {
        ["BTC"] = new Regex(@"\b[13][a-km-zA-HJ-NP-Z1-9]{25,34}\b|\bbc1[a-z0-9]{39,59}\b"),
        ["ETH"] = new Regex(@"\b0x[a-fA-F0-9]{40}\b"),
        ["TRC20"] = new Regex(@"\bT[A-Za-z1-9]{33}\b"),
        ["USDT-TRC20"] = new Regex(@"\bT[A-Za-z1-9]{33}\b"),
        ["LTC"] = new Regex(@"\b[LM3][a-km-zA-HJ-NP-Z1-9]{26,33}\b|\bltc1[a-z0-9]{39,59}\b"),
        ["XRP"] = new Regex(@"\br[a-zA-Z0-9]{24,34}\b"),
        ["ADA"] = new Regex(@"\baddr1[a-z0-9]{58}\b"),
        ["DOT"] = new Regex(@"\b1[a-zA-Z0-9]{47}\b"),
    };
    
    public DetectedAddress DetectBlockchainAddress(string text)
    {
        foreach (var pattern in _addressPatterns)
        {
            var match = pattern.Value.Match(text);
            if (match.Success)
            {
                return new DetectedAddress
                {
                    Address = match.Value,
                    Type = pattern.Key,
                    Position = match.Index
                };
            }
        }
        
        return null;
    }
}

public class DetectedAddress
{
    public string Address { get; set; }
    public string Type { get; set; }
    public int Position { get; set; }
}
```

### 3. 后端开发

**选择方案：NestJS + TypeScript**

**优势：**
- 企业级框架，类似 Spring Boot
- 强类型支持，代码维护性好
- 内置依赖注入和模块化架构
- 优秀的 WebSocket 和实时通信支持
- 丰富的生态系统

**替代方案：**
- ASP.NET Core (C#) - 高性能，跨平台
- FastAPI (Python) - 快速开发，AI 集成友好
- Go + Gin - 极高性能，内存占用低

### 3. 前端管理界面

**选择方案：Vue Vben Admin + Vue 3 + TypeScript + Vite**

**技术优势：**
- 基于 Vue 3 + TypeScript + Vite 的现代化企业级管理系统
- 开箱即用的后台管理解决方案，GitHub 星标 20k+
- 内置完善的权限管理、路由管理、状态管理
- 丰富的组件库和图表库集成
- 响应式设计，支持多主题切换
- 完善的国际化支持

**核心功能模块：**
- **实时监控面板**：多客户端屏幕预览网格布局
- **客户端管理**：设备列表、状态监控、配置管理
- **安全告警中心**：区块链地址检测告警、高清截图查看
- **白名单管理**：允许的区块链地址管理
- **系统管理**：用户权限、系统配置、日志管理
- **数据统计**：监控数据可视化、安全事件统计
- **通知中心**：实时安全告警通知

### 4. 数据库设计

**主数据库：MySQL 8.0**

```sql
-- 1. 客户端分组表
CREATE TABLE `client_groups` (
    `id` INT AUTO_INCREMENT PRIMARY KEY,
    `name` VARCHAR(100) NOT NULL UNIQUE COMMENT '分组名称',
    `description` TEXT COMMENT '分组描述',
    `color` VARCHAR(7) DEFAULT '#1890ff' COMMENT '分组颜色（十六进制）',
    `sort_order` INT DEFAULT 0 COMMENT '排序序号',
    `is_active` TINYINT(1) DEFAULT 1 COMMENT '是否激活',
    `created_by` INT COMMENT '创建人用户ID',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX `idx_active_sort` (`is_active`, `sort_order`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='客户端分组表';

-- 2. 客户端信息表
CREATE TABLE `clients` (
    `id` CHAR(36) PRIMARY KEY COMMENT '客户端UUID',
    `client_number` VARCHAR(50) NOT NULL UNIQUE COMMENT '客户端编号（用户输入）',
    `client_name` VARCHAR(255) NOT NULL COMMENT '客户端名称',
    `group_id` INT NOT NULL COMMENT '所属分组ID',
    `computer_name` VARCHAR(255) COMMENT '计算机名称',
    `username` VARCHAR(255) COMMENT '登录用户名',
    `ip_address` VARCHAR(45) COMMENT 'IP地址（支持IPv6）',
    `mac_address` VARCHAR(17) COMMENT 'MAC地址',
    `os_version` VARCHAR(255) COMMENT '操作系统版本',
    `client_version` VARCHAR(50) COMMENT '客户端程序版本',
    `screen_resolution` VARCHAR(20) COMMENT '屏幕分辨率',
    `status` ENUM('online', 'offline', 'error', 'installing') DEFAULT 'offline' COMMENT '状态',
    `last_heartbeat` TIMESTAMP NULL COMMENT '最后心跳时间',
    `first_connect` TIMESTAMP NULL COMMENT '首次连接时间',
    `total_online_time` BIGINT DEFAULT 0 COMMENT '总在线时长（秒）',
    `settings` JSON COMMENT '客户端配置（JSON格式）',
    `is_active` TINYINT(1) DEFAULT 1 COMMENT '是否激活',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (`group_id`) REFERENCES `client_groups`(`id`) ON UPDATE CASCADE ON DELETE RESTRICT,
    INDEX `idx_group_status` (`group_id`, `status`),
    INDEX `idx_status_heartbeat` (`status`, `last_heartbeat`),
    INDEX `idx_client_number` (`client_number`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='客户端信息表';

-- 3. 安全告警截图表
CREATE TABLE `security_screenshots` (
    `id` BIGINT AUTO_INCREMENT PRIMARY KEY,
    `client_id` CHAR(36) NOT NULL COMMENT '客户端ID',
    `alert_id` VARCHAR(64) NOT NULL UNIQUE COMMENT '告警唯一ID',
    `screenshot_time` TIMESTAMP NOT NULL COMMENT '截图时间',
    `minio_bucket` VARCHAR(100) NOT NULL COMMENT 'MinIO Bucket名称',
    `minio_object_key` VARCHAR(500) NOT NULL COMMENT 'MinIO对象KEY',
    `file_url` VARCHAR(1000) COMMENT '文件访问 URL',
    `cdn_url` VARCHAR(1000) COMMENT 'CDN加速 URL',
    `file_size` INT COMMENT '文件大小（字节）',
    `file_hash` VARCHAR(64) COMMENT '文件SHA256哈希值',
    `detected_address` TEXT NOT NULL COMMENT '检测到的区块链地址',
    `address_type` VARCHAR(20) NOT NULL COMMENT '地址类型（BTC/ETH/TRC20等）',
    `clipboard_content` TEXT NOT NULL COMMENT '完整剪切板内容',
    `risk_level` ENUM('LOW', 'MEDIUM', 'HIGH', 'CRITICAL') DEFAULT 'HIGH' COMMENT '风险等级',
    `is_reviewed` TINYINT(1) DEFAULT 0 COMMENT '是否已处理',
    `reviewed_by` INT NULL COMMENT '处理人用户ID',
    `reviewed_at` TIMESTAMP NULL COMMENT '处理时间',
    `review_note` TEXT COMMENT '处理备注',
    `alert_status` ENUM('pending', 'confirmed', 'false_positive', 'ignored') DEFAULT 'pending' COMMENT '告警状态',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (`client_id`) REFERENCES `clients`(`id`) ON DELETE CASCADE,
    INDEX `idx_client_time` (`client_id`, `screenshot_time` DESC),
    INDEX `idx_risk_status` (`risk_level`, `alert_status`),
    INDEX `idx_review_status` (`is_reviewed`, `created_at` DESC),
    INDEX `idx_address_type` (`address_type`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='安全告警截图表';

-- 4. 区块链地址白名单表
CREATE TABLE `blockchain_whitelist` (
    `id` BIGINT AUTO_INCREMENT PRIMARY KEY,
    `address` TEXT NOT NULL COMMENT '区块链地址',
    `address_hash` VARCHAR(64) NOT NULL UNIQUE COMMENT '地址哈希值（用于去重）',
    `address_type` VARCHAR(20) NOT NULL COMMENT '地址类型（BTC/ETH/TRC20等）',
    `label` VARCHAR(255) COMMENT '地址标签/备注',
    `category` VARCHAR(50) COMMENT '地址分类（公司钱包/交易所/合作伙伴等）',
    `created_by` INT NOT NULL COMMENT '创建人用户ID',
    `approved_by` INT COMMENT '审核人用户ID',
    `approved_at` TIMESTAMP NULL COMMENT '审核时间',
    `is_active` TINYINT(1) DEFAULT 1 COMMENT '是否激活',
    `expires_at` TIMESTAMP NULL COMMENT '过期时间（可选）',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX `idx_address_hash` (`address_hash`),
    INDEX `idx_type_active` (`address_type`, `is_active`),
    INDEX `idx_active_expires` (`is_active`, `expires_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='区块链地址白名单表';

-- 5. 系统用户表
CREATE TABLE `system_users` (
    `id` INT AUTO_INCREMENT PRIMARY KEY,
    `username` VARCHAR(50) NOT NULL UNIQUE COMMENT '用户名',
    `password` VARCHAR(255) NOT NULL COMMENT '密码哈希',
    `real_name` VARCHAR(100) COMMENT '真实姓名',
    `email` VARCHAR(255) UNIQUE COMMENT '邮箱',
    `phone` VARCHAR(20) COMMENT '手机号',
    `role` ENUM('admin', 'operator', 'viewer') DEFAULT 'viewer' COMMENT '用户角色',
    `permissions` JSON COMMENT '权限配置（JSON格式）',
    `is_active` TINYINT(1) DEFAULT 1 COMMENT '是否激活',
    `last_login` TIMESTAMP NULL COMMENT '最后登录时间',
    `login_count` INT DEFAULT 0 COMMENT '登录次数',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX `idx_username` (`username`),
    INDEX `idx_role_active` (`role`, `is_active`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='系统用户表';

-- 6. 系统日志表
CREATE TABLE `system_logs` (
    `id` BIGINT AUTO_INCREMENT PRIMARY KEY,
    `user_id` INT COMMENT '操作用户ID',
    `client_id` CHAR(36) COMMENT '相关客户端ID',
    `action` VARCHAR(100) NOT NULL COMMENT '操作类型',
    `target_type` VARCHAR(50) COMMENT '目标类型（client/whitelist/user等）',
    `target_id` VARCHAR(50) COMMENT '目标ID',
    `description` TEXT COMMENT '操作描述',
    `ip_address` VARCHAR(45) COMMENT '操作者IP',
    `user_agent` TEXT COMMENT '用户代理',
    `extra_data` JSON COMMENT '额外数据（JSON格式）',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX `idx_user_action` (`user_id`, `action`),
    INDEX `idx_client_time` (`client_id`, `created_at` DESC),
    INDEX `idx_action_time` (`action`, `created_at` DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='系统操作日志表';

-- 7. 客户端在线统记录表ਊCREATE TABLE `client_online_logs` (
    `id` BIGINT AUTO_INCREMENT PRIMARY KEY,
    `client_id` CHAR(36) NOT NULL COMMENT '客户端ID',
    `online_time` TIMESTAMP NOT NULL COMMENT '上线时间',
    `offline_time` TIMESTAMP NULL COMMENT '下线时间',
    `duration` INT COMMENT '在线时长（秒）',
    `ip_address` VARCHAR(45) COMMENT 'IP地址',
    `disconnect_reason` VARCHAR(100) COMMENT '断开原因',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (`client_id`) REFERENCES `clients`(`id`) ON DELETE CASCADE,
    INDEX `idx_client_time` (`client_id`, `online_time` DESC),
    INDEX `idx_duration` (`duration` DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='客户端在线时长记录表';
```

**缓存数据库：Redis 7.0**

**Redis 数据结构设计：**
```redis
# 1. 最新截图存储
KEY: screenshot:latest:{client_id}
TYPE: Hash
FIELDS:
  - minio_url: MinIO文件URL
  - cdn_url: CDN加速 URL
  - timestamp: 截图时间戳
  - file_size: 文件大小
  - file_hash: 文件哈希值
TTL: 3600 秒（1小时）

# 2. 客户端在线状态
KEY: client:online:{client_id}
TYPE: Hash
FIELDS:
  - status: online/offline
  - last_heartbeat: 最后心跳时间
  - ip_address: IP地址
  - connection_id: WebSocket连接ID
TTL: 300 秒（5分钟）

# 3. 白名单地址缓存
KEY: whitelist:addresses
TYPE: Set
VALUES: 所有激活的白名单地址哈希值
TTL: 1800 秒（30分钟）

# 4. 客户端分组缓存
KEY: client:groups
TYPE: Hash
FIELDS: {group_id}: {group_info_json}
TTL: 3600 秒（1小时）

# 5. WebSocket 连接管理
KEY: websocket:connections
TYPE: Hash
FIELDS: {connection_id}: {client_id}
TTL: 86400 秒（24小时）

# 6. 安全告警队列
KEY: security:alert:queue
TYPE: List
VALUES: 待处理的安全告警JSON数据

# 7. MinIO上传任务队列
KEY: minio:upload:queue
TYPE: List
VALUES: 待上传到MinIO的文件任务

# 8. 文件上传进度缓存
KEY: upload:progress:{task_id}
TYPE: Hash
FIELDS:
  - status: uploading/completed/failed
  - progress: 上传进度百分比
  - file_size: 文件大小
  - uploaded_size: 已上传大小
TTL: 1800 秒（30分钟）

# 7. 系统统计数据
KEY: stats:daily:{date}
TYPE: Hash
FIELDS:
  - total_clients: 客户端总数
  - online_clients: 在线客户端数
  - security_alerts: 安全告警数
  - screenshots_count: 截图总数
TTL: 2592000 秒（30天）
```

## 存储架构设计

### 双层存储策略

**1. 实时截图存储（Redis）**
- 存储内容：每个客户端最新一帧截图
- 存储时间：实时更新，只保留最新
- 预估容量：200MB（100客户端 × 2MB/帧）
- Redis Key 结构：`screenshot:${clientId}:latest`

**2. 安全告警截图存储（MinIO对象存储 + 数据库元数据）**
- **存储方式**：MinIO分布式对象存储
- **存储时间**：长期保存（可配置生命周期）
- **图像质量**：JPEG 95% 质量，确保文字清晰可读
- **Bucket结构**：
  ```
  monitoring-screenshots/
  ├── regular/{client_id}/{date}/latest.jpg     # 常规截图
  └── security/{client_id}/{date}/{alert_id}.jpg # 安全告警截图
  ```
- **数据库元数据**：MySQL存储文件路径、哈希、大小等元信息
- **CDN加速**：支持配置CDN加速图片访问

### MinIO存储策略与性能优化

**1. 图像压缩策略**
- **常规监控**：JPEG 60-70%，适合实时预览
- **安全告警**：JPEG 95%，确保文字清晰可读，用作证据保存

**2. MinIO存储架构**
```typescript
// MinIO存储配置
interface MinIOConfig {
  endpoint: string;
  bucketName: 'monitoring-screenshots';
  accessKey: string;
  secretKey: string;
  useSSL: boolean;
}

// 文件上传策略
class ScreenshotUploadStrategy {
  // 常规截图：直接覆盖上传
  async uploadRegularScreenshot(clientId: string, imageBuffer: Buffer) {
    const objectKey = `regular/${clientId}/${format(new Date(), 'yyyy-MM-dd')}/latest.jpg`;
    
    const result = await minioClient.putObject(
      BUCKET_NAME, 
      objectKey, 
      imageBuffer,
      {
        'Content-Type': 'image/jpeg',
        'Cache-Control': 'max-age=3600',
        'X-Client-Id': clientId
      }
    );
    
    // 更新Redis缓存URL
    await redis.hset(`screenshot:latest:${clientId}`, {
      minio_url: `${MINIO_ENDPOINT}/${BUCKET_NAME}/${objectKey}`,
      timestamp: Date.now(),
      file_size: imageBuffer.length
    });
  }
  
  // 安全告警截图：永久存储
  async uploadSecurityScreenshot(alertData: SecurityAlert) {
    const date = format(new Date(), 'yyyy-MM-dd');
    const objectKey = `security/${alertData.clientId}/${date}/${alertData.alertId}.jpg`;
    
    await minioClient.putObject(BUCKET_NAME, objectKey, alertData.screenshotBuffer, {
      'Content-Type': 'image/jpeg',
      'X-Alert-Id': alertData.alertId,
      'X-Risk-Level': alertData.riskLevel
    });
  }
}
```

**3. 生命周期管理**
```json
{
  "Rules": [
    {
      "ID": "RegularScreenshots",
      "Status": "Enabled", 
      "Filter": { "Prefix": "regular/" },
      "Expiration": { "Days": 7 }
    },
    {
      "ID": "SecurityScreenshots",
      "Status": "Enabled",
      "Filter": { "Prefix": "security/" },
      "Transitions": [
        { "Days": 90, "StorageClass": "STANDARD_IA" },
        { "Days": 365, "StorageClass": "GLACIER" }
      ]
    }
  ]
}
```

**4. 性能优化策略**

| 策略 | 说明 | 性能提升 |
|------|------|----------|
| **异步上传** | 截图先缓存到Redis，后台异步上传MinIO | 响应速度↑90% |
| **连接池** | MinIO客户端连接池，支持并发上传 | 吞吐量↑300% |  
| **预签名URL** | 客户端直传MinIO，减少服务器中转 | 带宽占用↓50% |
| **CDN加速** | 配置CDN加速图片访问 | 访问速度↑200% |
| **分片上传** | 大文件自动分片上传，支持断点续传 | 可靠性↑95% |

## 性能优化方案

### 1. 并发处理

**后端优化：**
```typescript
@Controller('api/screenshots')
export class ScreenshotController {
  @Post('upload')
  async uploadScreenshot(
    @Body() data: ScreenshotUploadDto,
    @Req() request: Request
  ) {
    // 异步处理，立即返回
    this.screenshotQueue.add('process-screenshot', data);
    return { success: true, message: 'Screenshot queued for processing' };
  }
}

@Processor('screenshot-queue')
export class ScreenshotProcessor {
  @Process('process-screenshot')
  async processScreenshot(job: Job<ScreenshotUploadDto>) {
    // 差分压缩
    const compressed = await this.compressionService.compress(job.data);
    
    // 存储到多层架构
    await Promise.all([
      this.redisService.cache(compressed),
      this.fileService.save(compressed),
      this.dbService.saveMetadata(compressed.metadata)
    ]);
    
    // WebSocket 广播更新
    this.websocketGateway.broadcastUpdate(compressed.clientId);
  }
}
```

### 2. 网络优化

**WebSocket 连接池：**
```typescript
@WebSocketGateway({
  cors: { origin: '*' },
  transports: ['websocket']
})
export class ScreenshotGateway {
  @WebSocketServer()
  server: Server;
  
  private clientConnections = new Map<string, Socket>();
  
  @SubscribeMessage('join-monitoring')
  handleJoinMonitoring(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { clientIds: string[] }
  ) {
    data.clientIds.forEach(clientId => {
      client.join(`client-${clientId}`);
    });
  }
  
  broadcastUpdate(clientId: string) {
    this.server.to(`client-${clientId}`).emit('screenshot-update', {
      clientId,
      timestamp: new Date(),
      url: `/api/screenshots/${clientId}/latest`
    });
  }
}
```

### 3. 前端优化

**基于 Vue Vben Admin 的监控面板设计：**
```vue
<template>
  <PageWrapper dense contentFullHeight fixedHeight contentClass="flex">
    <BasicTable @register="registerTable" class="w-1/4 xl:w-1/5">
      <template #toolbar>
        <a-button type="primary" @click="handleCreate">
          添加客户端
        </a-button>
      </template>
      <template #bodyCell="{ column, record }">
        <template v-if="column.key === 'status'">
          <Tag :color="getStatusColor(record.status)">
            {{ getStatusText(record.status) }}
          </Tag>
        </template>
      </template>
    </BasicTable>
    
    <div class="flex-1 bg-white m-4 mr-0 overflow-hidden">
      <div class="monitoring-grid h-full p-4">
        <div 
          v-for="client in selectedClients" 
          :key="client.id"
          class="client-preview relative border rounded-lg overflow-hidden"
        >
          <div class="absolute top-2 left-2 z-10">
            <Tag :color="getStatusColor(client.status)" size="small">
              {{ client.name }}
            </Tag>
          </div>
          <img 
            :src="getLatestScreenshot(client.id)"
            :alt="client.name"
            class="w-full h-full object-cover"
            @load="onImageLoad"
            @error="onImageError"
          />
          <div class="absolute bottom-0 left-0 right-0 bg-black bg-opacity-50 text-white p-2 text-xs">
            <div class="flex justify-between">
              <span>{{ formatTime(client.lastUpdate) }}</span>
              <span>{{ client.resolution }}</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </PageWrapper>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import { BasicTable, useTable, TableAction } from '/@/components/Table';
import { PageWrapper } from '/@/components/Page';
import { Tag } from 'ant-design-vue';
import { useWebSocket } from '/@/hooks/web/useWebSocket';
import { getClientList } from '/@/api/monitoring';

interface Client {
  id: string;
  name: string;
  status: 'online' | 'offline' | 'error';
  lastUpdate: Date;
  resolution: string;
  ipAddress: string;
}

const selectedClients = ref<Client[]>([]);

const columns = [
  { title: '客户端名称', dataIndex: 'name', key: 'name' },
  { title: 'IP地址', dataIndex: 'ipAddress', key: 'ipAddress' },
  { title: '状态', dataIndex: 'status', key: 'status' },
  { title: '最后活跃', dataIndex: 'lastUpdate', key: 'lastUpdate' },
];

const [registerTable, { reload, getSelectRows }] = useTable({
  title: '客户端列表',
  api: getClientList,
  columns,
  formConfig: {
    labelWidth: 120,
    schemas: [
      {
        field: 'name',
        label: '客户端名称',
        component: 'Input',
        colProps: { span: 8 },
      },
      {
        field: 'status',
        label: '状态',
        component: 'Select',
        componentProps: {
          options: [
            { label: '在线', value: 'online' },
            { label: '离线', value: 'offline' },
            { label: '错误', value: 'error' },
          ],
        },
        colProps: { span: 8 },
      },
    ],
  },
  useSearchForm: true,
  showTableSetting: true,
  bordered: true,
  rowSelection: {
    type: 'checkbox',
    onChange: (selectedRowKeys, selectedRows) => {
      selectedClients.value = selectedRows;
    },
  },
});

// WebSocket 连接
const { connect, disconnect } = useWebSocket({
  url: 'ws://localhost:47831',
  onMessage: (data) => {
    if (data.type === 'screenshot-update') {
      updateClientScreenshot(data.clientId, data.url);
    }
  },
});

onMounted(() => {
  connect();
});

const updateClientScreenshot = (clientId: string, url: string) => {
  const img = document.querySelector(`img[data-client="${clientId}"]`) as HTMLImageElement;
  if (img) {
    img.src = `${url}?t=${Date.now()}`;
  }
};

const getStatusColor = (status: string) => {
  const colorMap = {
    online: 'success',
    offline: 'default',
    error: 'error',
  };
  return colorMap[status] || 'default';
};
</script>

<style scoped>
.monitoring-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 16px;
  height: 100%;
  overflow-y: auto;
}

.client-preview {
  aspect-ratio: 16/9;
  min-height: 200px;
}
</style>
```

## 部署架构

### 1. 容器化部署

**Docker Compose 配置：**
```yaml
version: '3.8'
services:
  backend:
    build: ./backend
    ports:
      - "47831:3001"
    environment:
      - DATABASE_URL=mysql://user:pass@mysql:3306/monitoring
      - REDIS_URL=redis://redis:6379
      - MINIO_ENDPOINT=http://minio:9000
      - MINIO_ACCESS_KEY=minioadmin
      - MINIO_SECRET_KEY=minioadmin123
      - MINIO_BUCKET=monitoring-screenshots
    depends_on:
      - mysql
      - redis
      - minio
    volumes:
      - ./data/screenshots:/app/data/screenshots
  
  frontend:
    build: ./frontend
    ports:
      - "47830:3000"
    depends_on:
      - backend
  
  mysql:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=rootpass
      - MYSQL_DATABASE=monitoring
      - MYSQL_USER=user
      - MYSQL_PASSWORD=pass
      - MYSQL_CHARSET=utf8mb4
      - MYSQL_COLLATION=utf8mb4_unicode_ci
    volumes:
      - mysql_data:/var/lib/mysql
    command: --default-authentication-plugin=mysql_native_password
  
  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
  
  minio:
    image: minio/minio:latest
    ports:
      - "47823:9000"
      - "47824:9090"
    environment:
      - MINIO_ROOT_USER=minioadmin
      - MINIO_ROOT_PASSWORD=minioadmin123
      - MINIO_DEFAULT_BUCKETS=monitoring-screenshots
    volumes:
      - minio_data:/data
    command: server /data --console-address ":9090"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3
  
  nginx:
    image: nginx:alpine
    ports:
      - "47825:80"
      - "47826:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - frontend
      - backend

volumes:
  mysql_data:
  redis_data:
  minio_data:
```

### 2. 负载均衡配置

**Nginx 配置：**
```nginx
upstream backend {
    server backend1:47831;
    server backend2:47831;
    server backend3:47831;
}

upstream frontend {
    server frontend1:47830;
    server frontend2:47830;
}

server {
    listen 80;
    server_name monitoring.example.com;
    
    location /api/ {
        proxy_pass http://backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
    
    location /socket.io/ {
        proxy_pass http://backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    location / {
        proxy_pass http://frontend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

## 性能指标预估

### 1. 资源消耗

**单客户端（1 FPS）：**
- 网络带宽：平均 128 KB/s，峰值 800 KB/s
- 存储空间：2MB（仅最新截图）+ 告警截图不定期
- 内存占用：客户端 50-100 MB，服务端 10 MB

**100 客户端规模：**
- 总带宽：平均 28.5 Mbps，峰值 50-80 Mbps
- 存储需求：
  - 实时截图：200MB（Redis缓存） + 700MB（MinIO热存储7天）
  - 安全告警：按需存储，预估每月 1-10GB（MinIO长期保存）
- 服务器内存：4-8 GB（大幅减少）
- CPU 使用率：2-4 核心，30-50% 利用率

### 2. 扩展性指标

**并发处理能力：**
- 单服务器：1000+ 客户端同时在线
- 响应时间：截图上传 < 50ms（异步+MinIO）
- 查询速度：实时截图 < 100ms（Redis），历史截图 < 300ms（MinIO+CDN）
- 上传吞吐量：500+ 截图/秒（MinIO连接池）
- 系统可用性：99.9% 在线率

**MinIO性能指标：**
- 单实例吞吐量：最高 55GB/s
- 并发连接数：10,000+
- 延迟：平均 < 10ms
- 可靠性：99.999999999%（11个9）
- 扩展能力：支持PB级存储

**水平扩展：**
- 支持多服务器集群部署
- 数据库读写分离
- Redis 集群缓存
- CDN 静态资源加速

## 安全考虑

### 1. 数据传输安全
- HTTPS/WSS 加密传输
- JWT Token 身份认证
- API 访问频率限制
- 客户端证书验证

### 2. 数据存储安全
- 数据库连接加密
- 敏感信息脱敏
- 定期数据备份
- 访问日志审计

### 3. 系统安全
- 容器安全扫描
- 网络隔离配置
- 防火墙规则设置
- 入侵检测系统

## 开发计划

### Phase 1: MVP 开发（4-6 周）
1. **Week 1-2**: 客户端基础功能开发
   - 屏幕截图捕获
   - JPEG 压缩
   - 剪切板监控实现
   - 区块链地址检测算法

2. **Week 3-4**: 后端 API 开发
   - NestJS 项目搭建
   - 截图接收和存储（Redis）
   - PostgreSQL 数据库设计
   - 安全告警 API
   - 白名单管理 API

3. **Week 5-6**: 前端管理界面
   - Vue Vben Admin 项目搭建和定制
   - 实时监控面板
   - 安全告警中心界面
   - 白名单管理界面
   - 客户端管理和权限系统

### Phase 2: 功能增强（3-4 周）
1. **安全功能完善**
   - 高清告警截图长期存储
   - 告警通知系统
   - 安全事件统计分析
2. **WebSocket 实时通信**
3. **性能监控和调优**

### Phase 3: 生产部署（2-4 周）
1. **Docker 容器化**
2. **负载均衡配置**
3. **监控告警系统**
4. **安全加固**

## 总结

本技术方案采用现代化的技术栈，在保证高性能、高可用性的同时，新增了重要的安全监控功能：

### 核心特性
1. **简化存储架构**：只保存最新截图，大幅降低存储成本和系统复杂度
2. **安全监控增强**：实时检测区块链地址复制行为，保护企业资产安全
3. **精确告警机制**：白名单过滤 + 高清截图证据保存，减少误报提升效率
4. **灵活扩展性**：模块化设计支持后续功能扩展

### 技术优势
- **资源优化**：存储需求从TB级别降至GB级别，节省90%+成本
- **响应速度**：实时截图 + 毫秒级告警响应
- **证据保全**：高清截图 + 完整上下文信息，满足审计需求
- **运维简化**：容器化部署 + 自动化监控，降低运维复杂度

整体架构设计合理，技术选型成熟，既满足传统监控需求，又提供了针对性的安全防护能力。