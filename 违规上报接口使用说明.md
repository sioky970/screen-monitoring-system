# 违规上报接口使用说明

## 📋 接口概述

违规上报接口用于客户端向服务器上报检测到的违规行为，支持同时上传违规截图和相关信息。

## 🔗 接口信息

### 基本信息
- **接口地址**: `POST /api/security/violations/report-with-screenshot`
- **服务器地址**: `http://your-server:3001`
- **认证方式**: 无需认证
- **请求格式**: `multipart/form-data`
- **响应格式**: `application/json`

## 📝 请求参数

### 必填参数

| 参数名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `file` | File | 违规截图文件 | screenshot.jpg |
| `clientId` | String | 客户端唯一标识符 | `65ffa6a7-2f4b-4ab2-b0d6-8db48840e520` |
| `violationType` | String | 违规类型 | `BLOCKCHAIN_ADDRESS` |
| `violationContent` | String | 违规内容 | `1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2` |
| `timestamp` | String | 违规发生时间 | `2025-08-22T10:30:00.000Z` |

### 可选参数

| 参数名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `additionalData` | String | 附加数据(JSON格式) | `{"clipboardContent":"复制的内容","applicationName":"Chrome"}` |

### 参数详细说明

#### violationType 支持的类型
- `BLOCKCHAIN_ADDRESS` - 区块链地址违规
- `SENSITIVE_CONTENT` - 敏感内容违规
- `UNAUTHORIZED_ACCESS` - 未授权访问

#### timestamp 格式
- 使用 ISO 8601 格式
- 包含时区信息
- 示例: `2025-08-22T10:30:00.000Z`

#### additionalData 结构
```json
{
  "clipboardContent": "检测到的剪贴板内容",
  "applicationName": "触发违规的应用程序名称",
  "windowTitle": "窗口标题",
  "processName": "进程名称",
  "riskLevel": "HIGH|MEDIUM|LOW"
}
```

## 📤 请求示例

### cURL 示例

```bash
curl -X POST "http://your-server:3001/api/security/violations/report-with-screenshot" \
  -F "file=@screenshot.jpg" \
  -F "clientId=65ffa6a7-2f4b-4ab2-b0d6-8db48840e520" \
  -F "violationType=BLOCKCHAIN_ADDRESS" \
  -F "violationContent=1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2" \
  -F "timestamp=2025-08-22T10:30:00.000Z" \
  -F "additionalData={\"clipboardContent\":\"发现比特币地址\",\"applicationName\":\"Chrome\"}"
```

### JavaScript 示例

```javascript
const formData = new FormData();
formData.append('file', screenshotFile);
formData.append('clientId', '65ffa6a7-2f4b-4ab2-b0d6-8db48840e520');
formData.append('violationType', 'BLOCKCHAIN_ADDRESS');
formData.append('violationContent', '1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2');
formData.append('timestamp', new Date().toISOString());
formData.append('additionalData', JSON.stringify({
  clipboardContent: '发现比特币地址',
  applicationName: 'Chrome'
}));

fetch('http://your-server:3001/api/security/violations/report-with-screenshot', {
  method: 'POST',
  body: formData
})
.then(response => response.json())
.then(data => console.log(data))
.catch(error => console.error('Error:', error));
```

### Python 示例

```python
import requests
import json
from datetime import datetime

url = "http://your-server:3001/api/security/violations/report-with-screenshot"

files = {
    'file': ('screenshot.jpg', open('screenshot.jpg', 'rb'), 'image/jpeg')
}

data = {
    'clientId': '65ffa6a7-2f4b-4ab2-b0d6-8db48840e520',
    'violationType': 'BLOCKCHAIN_ADDRESS',
    'violationContent': '1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2',
    'timestamp': datetime.now().isoformat() + 'Z',
    'additionalData': json.dumps({
        'clipboardContent': '发现比特币地址',
        'applicationName': 'Chrome'
    })
}

response = requests.post(url, files=files, data=data)
print(response.json())
```

## 📥 响应格式

### 成功响应

**HTTP状态码**: `201 Created`

```json
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "success": true,
    "message": "违规事件上报成功",
    "alertId": 16238,
    "screenshotUrl": "/storage/screenshots/client-id/alerts/screenshot-filename.jpg"
  },
  "success": true,
  "timestamp": "2025-08-22T10:30:00.000Z"
}
```

### 响应字段说明

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `code` | Number | 业务状态码，200表示成功 |
| `message` | String | 操作结果描述 |
| `data.success` | Boolean | 操作是否成功 |
| `data.message` | String | 详细成功信息 |
| `data.alertId` | Number | 生成的告警记录ID |
| `data.screenshotUrl` | String | 上传截图的访问路径 |
| `success` | Boolean | 整体请求是否成功 |
| `timestamp` | String | 服务器响应时间 |

### 错误响应

**HTTP状态码**: `400 Bad Request` / `500 Internal Server Error`

```json
{
  "code": 400,
  "message": "请求参数错误",
  "error": "客户端ID不存在",
  "success": false,
  "timestamp": "2025-08-22T10:30:00.000Z"
}
```

## ⚠️ 注意事项

### 文件要求
- **支持格式**: JPG, JPEG, PNG, BMP
- **文件大小**: 建议不超过10MB
- **图片尺寸**: 无特殊限制，建议不超过4K分辨率

### 客户端ID要求
- 必须是有效的UUID格式
- 客户端必须已在系统中注册
- 如客户端不存在，接口将返回错误

### 时间戳要求
- 必须使用ISO 8601格式
- 建议使用UTC时间
- 时间不能超过当前时间24小时

### 网络要求
- 确保客户端能访问服务器地址
- 建议使用HTTPS协议（生产环境）
- 超时时间建议设置为30秒以上

## 🔍 常见错误码

| 错误码 | 说明 | 解决方案 |
|--------|------|----------|
| 400 | 请求参数错误 | 检查必填参数是否完整 |
| 404 | 客户端不存在 | 确认clientId是否正确注册 |
| 413 | 文件过大 | 压缩图片或降低分辨率 |
| 415 | 不支持的文件格式 | 使用支持的图片格式 |
| 500 | 服务器内部错误 | 联系系统管理员 |

## 🚀 最佳实践

### 1. 错误处理
```javascript
try {
  const response = await fetch(url, options);
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  const result = await response.json();
  if (!result.success) {
    throw new Error(result.message);
  }
  return result.data;
} catch (error) {
  console.error('上报失败:', error.message);
  // 实现重试逻辑或本地缓存
}
```

### 2. 重试机制
- 网络错误时实现指数退避重试
- 最大重试次数建议不超过3次
- 重试间隔: 1s, 2s, 4s

### 3. 本地缓存
- 网络不可用时将数据缓存到本地
- 网络恢复后批量上报缓存的违规事件
- 避免重复上报相同的违规事件

## 📋 集成检查清单

### 开发阶段
- [ ] 确认服务器地址和端口
- [ ] 获取有效的客户端ID
- [ ] 实现文件上传功能
- [ ] 添加错误处理逻辑
- [ ] 实现重试机制
- [ ] 添加本地缓存功能

### 测试阶段
- [ ] 测试各种违规类型
- [ ] 测试不同格式的图片文件
- [ ] 测试网络异常情况
- [ ] 验证错误处理是否正常
- [ ] 检查重试机制是否生效

### 生产部署
- [ ] 配置正确的服务器地址
- [ ] 启用HTTPS协议
- [ ] 设置合适的超时时间
- [ ] 配置日志记录
- [ ] 监控接口调用情况

## 🔧 SDK 示例

### C# 示例

```csharp
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json;

public class ViolationReporter
{
    private readonly HttpClient _httpClient;
    private readonly string _serverUrl;
    private readonly string _clientId;

    public ViolationReporter(string serverUrl, string clientId)
    {
        _httpClient = new HttpClient();
        _serverUrl = serverUrl;
        _clientId = clientId;
    }

    public async Task<ViolationResponse> ReportViolationAsync(
        byte[] screenshotData,
        string violationType,
        string violationContent,
        object additionalData = null)
    {
        var url = $"{_serverUrl}/api/security/violations/report-with-screenshot";

        using var content = new MultipartFormDataContent();
        content.Add(new ByteArrayContent(screenshotData), "file", "screenshot.jpg");
        content.Add(new StringContent(_clientId), "clientId");
        content.Add(new StringContent(violationType), "violationType");
        content.Add(new StringContent(violationContent), "violationContent");
        content.Add(new StringContent(DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ss.fffZ")), "timestamp");

        if (additionalData != null)
        {
            content.Add(new StringContent(JsonConvert.SerializeObject(additionalData)), "additionalData");
        }

        var response = await _httpClient.PostAsync(url, content);
        var responseContent = await response.Content.ReadAsStringAsync();

        return JsonConvert.DeserializeObject<ViolationResponse>(responseContent);
    }
}

public class ViolationResponse
{
    public int Code { get; set; }
    public string Message { get; set; }
    public ViolationData Data { get; set; }
    public bool Success { get; set; }
    public DateTime Timestamp { get; set; }
}

public class ViolationData
{
    public bool Success { get; set; }
    public string Message { get; set; }
    public int AlertId { get; set; }
    public string ScreenshotUrl { get; set; }
}
```

### Java 示例

```java
import okhttp3.*;
import com.google.gson.Gson;
import java.io.File;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

public class ViolationReporter {
    private final OkHttpClient client;
    private final String serverUrl;
    private final String clientId;
    private final Gson gson;

    public ViolationReporter(String serverUrl, String clientId) {
        this.client = new OkHttpClient();
        this.serverUrl = serverUrl;
        this.clientId = clientId;
        this.gson = new Gson();
    }

    public ViolationResponse reportViolation(
            File screenshotFile,
            String violationType,
            String violationContent,
            Map<String, Object> additionalData) throws Exception {

        String url = serverUrl + "/api/security/violations/report-with-screenshot";

        MultipartBody.Builder builder = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("file", screenshotFile.getName(),
                        RequestBody.create(screenshotFile, MediaType.parse("image/jpeg")))
                .addFormDataPart("clientId", clientId)
                .addFormDataPart("violationType", violationType)
                .addFormDataPart("violationContent", violationContent)
                .addFormDataPart("timestamp", Instant.now().toString());

        if (additionalData != null) {
            builder.addFormDataPart("additionalData", gson.toJson(additionalData));
        }

        Request request = new Request.Builder()
                .url(url)
                .post(builder.build())
                .build();

        try (Response response = client.newCall(request).execute()) {
            String responseBody = response.body().string();
            return gson.fromJson(responseBody, ViolationResponse.class);
        }
    }
}
```

## 📞 技术支持

### 联系方式
- **技术文档**: 查看完整API文档
- **问题反馈**: 通过系统管理员反馈技术问题
- **更新通知**: 关注接口版本更新

### 常见问题FAQ

**Q: 如何获取客户端ID？**
A: 客户端ID需要通过系统管理员分配，或通过客户端注册接口获取。

**Q: 支持批量上报吗？**
A: 当前版本不支持批量上报，需要逐个调用接口。

**Q: 截图文件会保存多久？**
A: 截图文件会永久保存在服务器存储中，用于违规事件的证据保存。

**Q: 接口有调用频率限制吗？**
A: 目前没有严格的频率限制，但建议合理控制调用频率，避免对服务器造成压力。

---

**文档版本**: v1.0
**最后更新**: 2025-08-22
**适用版本**: 后端 v1.0.0+
